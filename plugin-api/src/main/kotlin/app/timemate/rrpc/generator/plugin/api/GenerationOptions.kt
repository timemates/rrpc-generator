package app.timemate.rrpc.generator.plugin.api

import kotlinx.serialization.Serializable
import kotlinx.serialization.protobuf.ProtoNumber
import kotlinx.serialization.protobuf.ProtoPacked
import okio.Path
import okio.Path.Companion.toPath
import app.timemate.rrpc.generator.plugin.api.GenerationOptions.Companion.PERMIT_PACKAGE_CYCLES
import kotlin.jvm.JvmInline

/**
 * A set of options for code generation, represented as a map of option names to values.
 *
 * `GenerationOptions` provides a structured way to retrieve configuration values for code generation,
 * where options are defined as instances of `GenerationOption`. Each option, such as
 * [PERMIT_PACKAGE_CYCLES], is associated with a key and an expected type.
 *
 * @property map A map containing option names as keys and corresponding values.
 * @constructor Creates a new instance with the specified options map.
 *
 * @see GenerationOption
 */
@Serializable
@JvmInline
public value class GenerationOptions private constructor(private val map: Map<String, OptionValue>) {
    /**
     * A collection of predefined options for code generation.
     */
    public companion object {
        public fun create(block: Builder.() -> Unit): GenerationOptions {
            return Builder().apply(block).build()
        }

        public val SOURCE_INPUT: RepeatableGenerationOption<Path> = GenerationOption.repeatable(
            name = "source_input",
            description = "Folder with .proto files to be used for generation (repeatable).",
            valueKind = OptionTypeKind.Text,
            constructor = { it.toPath() },
        )

        public val CONTEXT_INPUT: RepeatableGenerationOption<Path> = GenerationOption.repeatable(
            name = "context_input",
            description = "Folder with .proto files to be used for generation (repeatable). This files will be used to resolve references only. Useful if the code was already generated by the dependency you have.",
            valueKind = OptionTypeKind.Text,
            constructor = { it.toPath() },
        )

        public val PERMIT_PACKAGE_CYCLES: SingleGenerationOption<Boolean> = GenerationOption.single(
            name = "permit_package_cycles",
            description = "Indicates whether package cycles should be ignored while parsing .proto files.",
            valueKind = OptionTypeKind.Boolean,
            constructor = { it.toBooleanStrictOrNull() ?: false },
        )

        public val GEN_OUTPUT: SingleGenerationOption<Path> = GenerationOption.single(
            name = "gen_output",
            description = "Indicates where generation should write their files. All plugins have their own generation folder defined by their name.",
            valueKind = OptionTypeKind.Path,
            constructor = { it.toPath() },
        )
    }

    /**
     * Retrieves the value for a given [option], casting it to the expected type.
     *
     * @param option The [SingleGenerationOption] key whose value is requested.
     * @return The value of the option, or `null` if not found.
     */
    @Suppress("UNCHECKED_CAST")
    public operator fun <T> get(option: SingleGenerationOption<T>): T? {
        return map[option.name]?.let {
            option.valueFactory(
                (if (!it.isSingle) it.multiple.firstOrNull() else it.single) ?: return null
            )
        }
    }

    /**
     * Retrieves the values for a given [option], casting it to the expected type.
     *
     * @param option The [RepeatableGenerationOption] key whose value is requested.
     * @return The value of the option, or `null` if not found.
     */
    @Suppress("UNCHECKED_CAST")
    public operator fun <T> get(option: RepeatableGenerationOption<T>): List<T>? {
        val value = map[option.name] ?: return null
        val list = if (value.isSingle) listOf(value.single) else value.multiple

        return list.map { option.valueFactory(it) }
    }

    public val raw: Map<String, Any> get() = map.mapValues { (_, v) -> if (v.isSingle) v.single else v.multiple }

    public fun builder(block: Builder.() -> Unit): GenerationOptions = Builder(map.toMutableMap()).apply(block).build()

    public class Builder internal constructor(private val map: MutableMap<String, OptionValue> = mutableMapOf()) {
        public operator fun <T : Any> set(option: SingleGenerationOption<T>, value: String) {
            map[option.name] = OptionValue(single = value, isSingle = true)
        }

        public fun <T : Any> append(option: RepeatableGenerationOption<T>, value: String) {
            if (map.containsKey(option.name)) {
                @Suppress("UNCHECKED_CAST")
                map[option.name] = OptionValue(multiple = map[option.name]?.multiple?.plus(value) ?: listOf(value), isSingle = false)
            } else {
                map[option.name] = OptionValue(multiple = listOf(value), isSingle = false)
            }
        }

        public fun rawSet(name: String, value: String) {
            map[name] = OptionValue(single = value, isSingle = true)
        }

        public fun rawAppend(name: String, value: String) {
            if (map.containsKey(name)) {
                @Suppress("UNCHECKED_CAST")
                map[name] = OptionValue(multiple = map[name]?.multiple?.plus(value) ?: listOf(value), isSingle = false)
            } else {
                map[name] = OptionValue(multiple = listOf(value), isSingle = false)
            }
        }

        public fun build(): GenerationOptions {
            return GenerationOptions(map.toMap())
        }
    }

    @Serializable
    internal data class OptionValue(
        @ProtoNumber(1)
        val single: String = "",
        @ProtoPacked
        @ProtoNumber(2)
        val multiple: List<String> = emptyList(),
        @ProtoNumber(3)
        val isSingle: Boolean = true,
    )

}

public val GenerationOptions.contextInputs: List<Path>
    get() =
        this[GenerationOptions.CONTEXT_INPUT].orEmpty()

public val GenerationOptions.sourceInputs: List<Path>
    get() =
        this[GenerationOptions.SOURCE_INPUT].orEmpty()

public val GenerationOptions.isPackageCyclesPermitted: Boolean
    get() = this[PERMIT_PACKAGE_CYCLES] ?: false

/**
 * Represents an option for code generation, identified by its unique name.
 *
 * @param T The type of the value associated with this option.
 * @property name The unique identifier for the option.
 * @property description Descriptive information about option, value constraints, and so on.
 */
public sealed interface GenerationOption {
    public val name: String
    public val description: String?
    public val valueKind: OptionTypeKind

    public companion object {
        public fun <T> single(
            name: String,
            description: String,
            valueKind: OptionTypeKind,
            constructor: (String) -> T,
        ): SingleGenerationOption<T> {
            return SingleGenerationOption(name, description, valueKind, constructor)
        }

        public fun <T> repeatable(
            name: String,
            description: String,
            valueKind: OptionTypeKind,
            constructor: (String) -> T,
        ): RepeatableGenerationOption<T> {
            return RepeatableGenerationOption(name, description, valueKind, constructor)
        }
    }
}

@Serializable
public sealed interface OptionTypeKind {
    public val readableName: String

    @Serializable
    public data object Text : OptionTypeKind {
        override val readableName: String
            get() = "Text"
    }

    @Serializable
    public data object Boolean : OptionTypeKind {
        override val readableName: String
            get() = "Boolean"
    }

    @Serializable
    public sealed interface Number : OptionTypeKind {
        @Serializable
        public data object Int : Number {
            override val readableName: String
                get() = "Int"
        }

        @Serializable
        public data object Long : Number {
            override val readableName: String
                get() = "Long"
        }

        @Serializable
        public data object Float : Number {
            override val readableName: String
                get() = "Float"
        }

        @Serializable
        public data object Double : Number {
            override val readableName: String
                get() = "Double"
        }
    }

    @Serializable
    public data object Path : OptionTypeKind {
        override val readableName: String
            get() = "Path"
    }

    @Serializable
    public data class Choice(@ProtoNumber(1) public val variants: List<String>) : OptionTypeKind {
        override val readableName: String
            get() = "Choice (${variants.joinToString(", ")})"
    }
}

@Suppress("unused")
public data class SingleGenerationOption<T>(
    public override val name: String,
    public override val description: String,
    override val valueKind: OptionTypeKind,
    public val valueFactory: (String) -> T,
) : GenerationOption

@Suppress("unused")
public data class RepeatableGenerationOption<T>(
    public override val name: String,
    public override val description: String,
    override val valueKind: OptionTypeKind,
    public val valueFactory: (String) -> T,
) : GenerationOption